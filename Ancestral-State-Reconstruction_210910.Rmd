---
title: "Ancestral-State-Reconstruction_210910"
author: "Lily Zhong"
date: "3/21/2022"
output: html_document
editor_options: 
  chunk_output_type: inline
---

### Load Packages

```{r load packages, message = FALSE}
# data manipulation
library(tidyverse)
library(stringr)
library(lubridate)
# phylogenetic
library(ape)
library(phytools)
library(castor)
library(phangorn)
# statistical testing
library(survival)
# plotting
library(ggplot2)
library(gridExtra)
library(RColorBrewer)
```

### Import data

#### NextStrain Subsample Tree

```{r import NextStrain Subsample Tree}
# read in the tree
tree <- read.tree("nextstrain_timetree_210910.nwk")

# basic info
length(tree$edge.length) # 6275 edges
tree$Nnode # 2827 internal nodes
length(tree$tip.label) # 3449 tip labels = sequence names
tree$root.edge # 0
is.rooted(tree) # TRUE
is.binary(tree) # FALSE: not fully resolved
summary(tree$edge.length)
#     Min.    1st Qu.   Median     Mean     3rd Qu.     Max.
# -0.001012  0.026966  0.070278  0.120726  0.166907  1.342243 
# Why is there negative lengths???
sum(tree$edge.length < 0) # 9 edges has negative lengths
sum(tree$edge.length == 0) # 257 edges has negative lengths

# plot
# plot(tree, type = "phylogram", direction = "right", show.tip.label = FALSE)
```

#### NextClade Variant Calling

```{r import NextStrain Subsample NextClade Variant Calling, message = FALSE}
# read in the NextClade csv & select useful variables
sequence <- read_csv2("nextclade_210910.csv")
sequence <- sequence %>% 
            select(seqName, clade, Nextclade_pango, aaSubstitutions, aaDeletions)
# dim(sequence) # (3442, 5) -- missing sequences for 7/3449 of tree tips

# merge non-synonymous substitutions with deletions
sequence <- sequence %>% 
            mutate(mutation = ifelse(is.na(aaDeletions),
                                     aaSubstitutions, 
                                     paste(aaSubstitutions, aaDeletions, sep = ",")))

# check if the tree tip labels match with the sequence names
# head(tree$tip.label); head(sequence$seqName) # compare
# length(intersect(tree$tip.label, sequence$seqName)) # 0 match
```

#### Patient Metadata

```{r import NextStrain Subsample Patient Metadata, message = FALSE}
# read in the metadata tsv
meta <- read_tsv("nextstrain_patient_meta_210910.tsv")
```

### Match sequence names with tree tip names

```{r Process Sequence Names to Match Tree Tip Names}
# explore common patterns in the sequence labels
# str_view(sequence$seqName, "hCoV-19/.+/.+/\\d{4}")
sum(str_detect(sequence$seqName, "hCoV-19/.+/.+/\\d{4}"))
    # 3442 has pattern 1 = "hCoV-19/Region/ID/time"
# str_view(sequence$seqName, "EPI_ISL_\\d*")
sum(str_detect(sequence$seqName, "EPI_ISL_\\d*"))
    # 3442 has pattern 2 = "EPI_ISL_#"

# explore common patterns in the tree tip labels
# str_view(tree$tip.label, "hCoV-19/.+/.+/\\d{4}")
sum(str_detect(tree$tip.label, "hCoV-19/.+/.+/\\d{4}"))
    # 3449 has pattern 1 = "hCoV-19/Region/ID/time"


# step 1: extract parts of sequence labels that have the same pattern as the tree tip label
sequence <- sequence %>% 
            mutate(GISAID_ID = seqName) %>% # GISAID_ID for backup
            mutate(seqName = str_extract(.$seqName, "hCoV-19/.+/.+/\\d{4}")) %>% # tree tip
            mutate(Accession_ID = GISAID_ID) %>% 
            mutate(Accession_ID = str_extract(.$Accession_ID, "EPI_ISL_\\d*")) %>% # meta
            select(GISAID_ID, seqName, Accession_ID, clade, Nextclade_pango, mutation)
# check 1
length(intersect(tree$tip.label, sequence$seqName)) # 2910 matches
# names only in tree tip label
only_tree <- data.frame(tree_lab = setdiff(tree$tip.label, sequence$seqName))
only_tree <- only_tree %>% arrange(tree_lab)
dim(only_tree) # 539
# names only in sequence label
only_seq <- sequence %>%
            mutate(seq_lab = seqName) %>%
            select(seq_lab, GISAID_ID) %>%
            # keep GISAID_ID to match back to the sequence data set later
            filter(seq_lab %in% setdiff(sequence$seqName, tree$tip.label)) %>%
            # only in sequence label
            arrange(seq_lab)
dim(only_seq) # (532, 2)
# add NAs so that the dim matches
only_seq[533:539, ] <- NA
dim(only_seq) # (532, 2)
mismatch <- cbind(only_tree, only_seq)
# View(mismatch)

# step 2: correct for sequence names
mismatch <- mismatch %>%
            # remove spaces in country names
            mutate(seq_lab = str_replace_all(mismatch$seq_lab, "\\s", "")) %>%
            # major changes in region
            mutate(seq_lab = case_when(str_detect(seq_lab, "ed'Iv") ~ str_replace(seq_lab, "'", "-"),
                                       str_detect(seq_lab, "Aruba") ~ str_replace(seq_lab, "Aruba", "Netherlands"),
                                       str_detect(seq_lab, "Bonaire") ~ str_replace(seq_lab, "Bonaire", "Netherlands"),
                                       str_detect(seq_lab, "Curacao") ~ str_replace(seq_lab, "Curacao", "Netherlands"),
                                       str_detect(seq_lab, "FrenchGuiana") ~ str_replace(seq_lab, "FrenchGuiana", "Guyane"),
                                       str_detect(seq_lab, "PuertoRico") ~ str_replace(seq_lab, "PuertoRico", "USA"),
                                       TRUE ~ seq_lab)) %>%
            # minor changes in region
            mutate(seq_lab = case_when(str_detect(seq_lab, "Netherlands/AW-RIVM-51693") ~ str_replace(seq_lab, "Netherlands/AW-RIVM-51693", "Aruba/-RIVM-51693"),
                                       str_detect(seq_lab, "Netherlands/AW-RIVM-52747") ~ str_replace(seq_lab, "Netherlands/AW-RIVM-52747", "Aruba/-RIVM-52747"),
                                       str_detect(seq_lab, "Netherlands/BQ-RIVM-51731") ~ str_replace(seq_lab, "Netherlands/BQ-RIVM-51731", "Bonaire/-RIVM-51731"),
                                       str_detect(seq_lab, "Netherlands/BQ-RIVM-51753") ~ str_replace(seq_lab, "Netherlands/BQ-RIVM-51753", "Bonaire/-RIVM-51753"),
                                       str_detect(seq_lab, "Netherlands/BQ-RIVM-51792") ~ str_replace(seq_lab, "Netherlands/BQ-RIVM-51792", "Bonaire/-RIVM-51792"),
                                       str_detect(seq_lab, "SX-RIVM-52857") ~ str_replace(seq_lab, "SX-RIVM-52857", "-RIVM-52857"),
                                       str_detect(seq_lab, "CzechRepublic/CSQ0207") ~ str_replace(seq_lab, "CzechRepublic/CSQ0207", "Czech_Republic/CSQ0207"),
                                       TRUE ~ seq_lab)) %>%
            # corrections for date: 2021 & 2020
            mutate(seq_lab = case_when(str_detect(seq_lab, "CHRF-0356/2020") ~ str_replace(seq_lab, "CHRF-0356/2020", "CHRF-0356/2021"),
                                       str_detect(seq_lab, "AM-FIOCRUZ-21840050SRD/2020") ~ str_replace(seq_lab, "AM-FIOCRUZ-21840050SRD/2020", "AM-FIOCRUZ-21840050SRD/2021"),
                                       str_detect(seq_lab, "Greece/6462/2020") ~ str_replace(seq_lab, "Greece/6462/2020", "Greece/6462/2021"), 
                                       str_detect(seq_lab, "AGU-InDRE_F11762B_S1084/2020") ~ str_replace(seq_lab, "AGU-InDRE_F11762B_S1084/2020", "AGU-InDRE_F11762B_S1084/2021"),
                                       str_detect(seq_lab, "Oman/520278568/2020") ~ str_replace(seq_lab, "Oman/520278568/2020", "Oman/520278568/2021"),
                                       str_detect(seq_lab, "Oman/5211886/2020") ~ str_replace(seq_lab, "Oman/5211886/2020", "Oman/5211886/2021"),
                                       str_detect(seq_lab, "Oman/52180/2020") ~ str_replace(seq_lab, "Oman/52180/2020", "Oman/52180/2021"),
                                       str_detect(seq_lab, "Romania/SC08965/2020") ~ str_replace(seq_lab, "Romania/SC08965/2020", "Romania/SC08965/2021"), #
                                       TRUE ~ seq_lab)) %>%
            # other minor changes in labels
            mutate(seq_lab = case_when(str_detect(seq_lab, "MG-HLAGYN-1853475/2021") ~ str_replace(seq_lab, "MG-HLAGYN-1853475/2021", "GO-HLAGYN-1853475/2021"),
                                       str_detect(seq_lab, "BKE1545-bc17") ~ str_replace(seq_lab, "BKE1545-bc17", "COV-BKE1545/bc17"),
                                       str_detect(seq_lab, "CRIE-L189B0546b") ~ str_replace(seq_lab, "CRIE-L189B0546b", "UA43-CRIE-L189B0546b"),
                                       str_detect(seq_lab, "COA-InDRE-IBT-28845-NC") ~ str_replace(seq_lab, "COA-InDRE-IBT-28845-NC", "COA-InDRE-IBT-28845/NC"),
                                       str_detect(seq_lab, "DUR-InDRE-IBT-34067-NC") ~ str_replace(seq_lab, "DUR-InDRE-IBT-34067-NC", "DUR-InDRE-IBT-34067/NC"),
                                       str_detect(seq_lab, "VD-GEN2699") ~ str_replace(seq_lab, "VD-GEN2699", "GEN2699"),
                                       str_detect(seq_lab, "Kyiv-F2-6") ~ str_replace(seq_lab, "Kyiv-F2-6", "Kyiv/F2-6"), #
                                       str_detect(seq_lab, "GA-CDC-3784545-001") ~ str_replace(seq_lab, "GA-CDC-3784545-001", "GA-CDC-5100"),
                                       str_detect(seq_lab, "IL-CDC-02983522-001") ~ str_replace(seq_lab, "IL-CDC-02983522-001", "IL1"),
                                       str_detect(seq_lab, "NH-CDC-03068248-001") ~ str_replace(seq_lab, "NH-CDC-03068248-001", "NH_0033"),
                                       str_detect(seq_lab, "RI-CDC-03070138-001") ~ str_replace(seq_lab, "RI-CDC-03070138-001", "RI-CDC-KCPZ-3781"),
                                       str_detect(seq_lab, "SD-SDPHL-0361/2020") ~ str_replace(seq_lab, "SD-SDPHL-0361/2020", "SD-SDPHL-0361/2021"),
                                       str_detect(seq_lab, "TN-CDC-3981243-001") ~ str_replace(seq_lab, "TN-CDC-3981243-001", "TN-CDC-TX0A-6344"),
                                       str_detect(seq_lab, "VT-CDC-03068154-001") ~ str_replace(seq_lab, "VT-CDC-03068154-001", "VT-CDC-0303"),
                                       TRUE ~ seq_lab))
            
# check 2: all corresponding ones are matched, the rest are ones with no sequence info
length(intersect(mismatch$seq_lab, mismatch$tree_lab))
      # 532 mismatches resolved, 7 to be resolved
# View(data.frame(setdiff(mismatch$tree_lab, mismatch$seq_lab), 
#                 c(setdiff(mismatch$seq_lab, mismatch$tree_lab), rep(NA, 6))))

# step 3: match the ordering of tree_lab with seq_lab in mismatch data set
mismatch <- full_join(mismatch[1], mismatch[2:3], by = c("tree_lab" = "seq_lab")) %>%
            filter(!is.na(tree_lab))

# step 4: change the sequence names to the matched names & ordering of tree tip labels
# join
length(intersect(tree$tip.label, sequence$seqName)) # 2910/3449 matches
sequence <- full_join(sequence, mismatch, by = "GISAID_ID")
# check
sum(!is.na(sequence$tree_lab)) # 532 matched tree_lab & seq_lab + 7 unpaired tree_labs
sequence %>% filter(is.na(GISAID_ID)) # 7 missing ones with no sequence info
# match names
sequence <- sequence %>% 
            mutate(seqName = ifelse(!is.na(tree_lab),
                                    # has tree_lab means names were mismatched originally
                                    tree_lab,
                                    # use corrected names from mismatch data set
                                    seqName))
                                    # if not, keep original name
# check again
sum(!is.na(sequence$tree_lab))
      # 532 matched tree_lab & seq_lab + 7 unpaired tree_labs
sum(!is.na(sequence$seqName))
      # 3449 matched tree_lab & seqName
sequence %>% filter(is.na(GISAID_ID))
      # 7 missing ones with no sequence inf
length(intersect(sequence$seqName, tree$tip.label))
      # 3449/3449 matches between sequence name and tree tip label
setequal(sequence$seqName, tree$tip.label)
      # TRUE
identical(sequence$seqName, tree$tip.label)
      # FALSE: the order is wrong
# match order between tree tip label and seqName (sequence)
tree_tip_label <- data.frame(seqName = tree$tip.label) # extract ordering of tree tip label
sequence <- full_join(tree_tip_label, sequence, by = "seqName") # join: correct name order
# check again again
identical(sequence$seqName, tree$tip.label)
      # TRUE
sequence %>% filter(is.na(GISAID_ID))
      # 7 missing ones with no sequence inf
# remove intermediate data sets
rm(only_seq); rm(only_tree); rm(mismatch); rm(tree_tip_label)

# extract tree tip labels with missing sequence information
noSeq <- sequence$seqName[which(is.na(sequence$GISAID_ID))]
# check tree parameters before removing tips with no sequence information
length(tree$tip.label) # 3449 tips
tree$Nnode # 2827 internal nodes
length(tree$edge.length) # 6275 edges
dim(tree$edge) # (6275, 2)
# remove the tips from the sequence data set
tree <- drop.tip(tree, noSeq, trim.internal = TRUE)
      # Phylogenetic tree with 3442 tips and 2801 internal nodes.
      # Tip labels:
      #   hCoV-19/Wuhan/Hu-1/2019, hCoV-19/Wuhan/WH01/2019, hCoV-19/Taiwan/2/2020, 
      # hCoV-19/HongKong/HKPU23_2601/2020, hCoV-19/Thailand/SI200383-NT/2020, 
      # hCoV-19/Australia/VIC03/2020, ...
      # Rooted; includes branch lengths.
# check tree parameters after removing tips with no sequence information
length(tree$tip.label) # 3442 tips (-7 tips)
tree$Nnode # 2801 internal nodes (-26 internal nodes)
length(tree$edge.length) # 6275 edges (-33 edges)
dim(tree$edge) # (6242, 2)
summary(tree$edge.length)
#     Min.    1st Qu.   Median     Mean     3rd Qu.     Max.
# -0.001012  0.027213  0.070801  0.121154  0.167211  1.342243 
# Why is there negative lengths???
sum(tree$edge.length < 0) # 9 edges has negative lengths
sum(tree$edge.length == 0) # 237 edges has negative lengths

# merge sequence with meta & clean the data set for further processing 
sequence <- sequence %>%
            filter(!is.na(GISAID_ID)) %>%
            full_join(meta, by = c("Accession_ID" = "Accession ID")) %>% 
            select(GISAID_ID, seqName, `Virus name`, Accession_ID, clade, 
                   Nextclade_pango, mutation, `Collection date`, Location)

# find the time span of the whole sequence sample
summary(sequence$`Collection date`)
#         Min.      1st Qu.       Median         Mean      3rd Qu.         Max.     NA's 
# "2019-12-26" "2021-01-20" "2021-05-28" "2021-03-26" "2021-07-09" "2021-09-03"      "2"
``` 

### Create numeric vectors for ancestral state reconstruction

#### E484

```{r E484 vectors for mutations}
E484 <- sequence$mutation # E484 now has all mutations in each sequence
# sum(is.na(E484)) # 8 NAs = 8 sequences with 0 mutations
E484 <- ifelse(is.na(E484), "E", E484) # no mutation = "E" on amino acid number 484
# sum(is.na(E484)) # check: 0 NA
# sum(str_detect(E484, "(S:E484)([A-Z])")) # 494 sequences have substitution (any amino acid) on site 484
E484 <- ifelse(str_detect(E484, "(S:E484)([A-Z])"), 
               str_match(E484, "(S:E484)([A-Z])")[, 3], # if mutation, extract the substitution
               "E") # if no "E484" mutation pattern found = "E" on site 484
# sum(E484 != "E") # check: 494 matches
rbind(table(E484), prop.table(table(E484))) # calculate substitution patterns on E484

# create numeric vector of tip mutation for ASR
E484 <- data.frame(E484)
names(E484) <- "AA"
    # E484A, E484K, E484Q
E484 <- E484 %>% mutate(indAA = case_when(AA == "A" ~ 1,
                                          AA == "E" ~ 2, 
                                          AA == "K" ~ 3,
                                          AA == "Q" ~ 4))
E484_int <- as.integer(E484$indAA) # E484 for backup, E484_int for ASR: 1, 2, 3, 4
rbind(table(E484_int), prop.table(table(E484_int))) # check

# assigned matched names to E484_int for ASR
# identical(sequence$seqName, tree$tip.label) # TRUE: order and labels are the same
names(E484_int) <- sequence$seqName
identical(names(E484_int), tree$tip.label) # TRUE
```

#### N501

```{r N501 vectors for mutations}
N501 <- sequence$mutation # N501 now has all mutations in each sequence
# sum(is.na(N501)) # 8 NAs = 8 sequences with 0 mutations
N501 <- ifelse(is.na(N501), "N", N501) # no mutation = "N" on amino acid number 501
# sum(is.na(N501)) # check: 0 NA
# sum(str_detect(N501, "(S:N501)([A-Z])")) # 896 sequences have substitution (any amino acid) on site 501
N501 <- ifelse(str_detect(N501, "(S:N501)([A-Z])"), 
               str_match(N501, "(S:N501)([A-Z])")[, 3], # if mutation, extract the substitution
               "N") # if no "N501" mutation pattern found = "N" on site 501
# sum(N501 != "N") # check: 701 matches
rbind(table(N501), prop.table(table(N501))) # calculate substitution patterns on N501

# create numeric vector of tip mutation for ASR
N501 <- data.frame(N501)
names(N501) <- "AA"
      # N501S, N501T, N501Y
N501 <- N501 %>% mutate(indAA = case_when(AA == "N" ~ 1,
                                          AA == "S" ~ 2, 
                                          AA == "T" ~ 3,
                                          AA == "Y" ~ 4))
N501_int <- as.integer(N501$indAA) # N501 for backup, N501_int for ASR: 1, 2, 3, 4
rbind(table(N501_int), prop.table(table(N501_int))) # check

# assigned matched names to N501_int for ASR
# identical(sequence$seqName, tree$tip.label) # TRUE: order and labels are the same
names(N501_int) <- sequence$seqName
identical(names(N501_int), tree$tip.label) # TRUE
```

### Ancestral State Reconstruction

#### E484

```{r E484 Ancestral State Reconstruction}
# ASR with castor::asr_mk_model()
E484_ASR_mk <- asr_mk_model(tree, E484_int, Nstates = 4, rate_model = "ER", 
                            include_ancestral_likelihoods = TRUE, check_input = TRUE)
# dim(E484_ASR_mk$ancestral_likelihoods) # 2801 nodes * 4 states
E484_likelihood_mk <- E484_ASR_mk$ancestral_likelihoods
# from probabilities to states for internal nodes
E484_states <- c("A", "E", "K", "Q")
E484_mk <- NaN
for (i in 1:dim(E484_likelihood_mk)[1]){
  E484_mk[i] = E484_states[which.max(E484_likelihood_mk[i, ])]
  # max probability = state of internal nodes
}
table(E484_mk, useNA = "ifany") # E(2369) K(421) Q(11) = state count of internal nodes
```

#### N501

```{r N501 Ancestral State Reconstruction}
# ASR with castor::asr_mk_model()
N501_ASR_mk <- asr_mk_model(tree, N501_int, Nstates = 4, rate_model = "ER", 
                            include_ancestral_likelihoods = TRUE, check_input = TRUE)
# dim(N501_ASR_mk$ancestral_likelihoods) # 2801 nodes * 4 states
N501_likelihood_mk <- N501_ASR_mk$ancestral_likelihoods
# from probabilities to states for internal nodes
N501_states <- c("N", "S", "T", "Y")
N501_mk <- NaN
for (i in 1:dim(N501_likelihood_mk)[1]){
  N501_mk[i] = N501_states[which.max(N501_likelihood_mk[i, ])]
  # max probability = state of internal nodes
}
table(N501_mk, useNA = "ifany") # N(2015) T(4) Y(782) = state count of internal nodes
```

### Identify clades

#### E484 ASR

```{r identify clades based on E484 ASR}
# data frame: store the most-recent common ancestor information for each tip
clade <- data.frame(tip_label = names(E484_int),
                    # tip labels in format "hCoV-19/AREA/SEQUENCE/YEAR"
                    tip_node = 1:Ntip(tree), # node number of tips
                    tip_state = E484$AA, # "E, K, Q, R" state of tree tip
                    ancestor_node = NaN, # will hold ancestor node
                    ancestor_state = NaN, # will hold ASR ancestor node
                    row.names = NULL)

# find the oldest ancestor (deepest node with the same state) for each tip
for (tip in clade$tip_node){ 
  # will hold the node number of the oldest ancestor with the same mutation
  find = NaN 
  # loop over and check all ancestors (not just parent) of a tip
  for (ancestor in Ancestors(tree, tip, type = "all")){ 
    # if ancestor node state from ASR = tip state
    if (E484_mk[ancestor-Ntip(tree)] == E484$AA[tip]){ 
      # update ancestor if the state of the ancestor node is the same as the tip
      find = ancestor 
    } else{break}
  }
  # if no ancestor matches, use the tip itself
  find <- ifelse(is.na(find), tip, find)
  # match the ancestor and the corresponding tip
  clade$ancestor_node[which(clade$tip_node == tip)] <- find 
  # fill in the ASR state of the ancestor
  clade$ancestor_state[which(clade$tip_node == tip)] <- ifelse(find == tip, # if tip itself
                                                               E484$AA[find], # tip state
                                                               E484_mk[find-Ntip(tree)])
                                                               # ancestor state
}

# check: should be the same
identical(clade$tip_state, clade$ancestor_state) # TRUE
```

#### N501 ASR

```{r identify clades based on N501 ASR}
# data frame: store the most-recent common ancestor information for each tip
clade_N501 <- data.frame(tip_label = names(N501_int),
                         # tip labels in format "hCoV-19/AREA/SEQUENCE/YEAR"
                         tip_node = 1:Ntip(tree), # node number of tips
                         tip_state = N501$AA, # "E, K, Q, R" state of tree tip
                         ancestor_node = NaN, # will hold ancestor node
                         ancestor_state = NaN, # will hold ASR ancestor node
                         row.names = NULL)

# find the oldest ancestor (deepest node with the same state) for each tip
for (tip in clade_N501$tip_node){ 
  # will hold the node number of the oldest ancestor with the same mutation
  find = NaN 
  # loop over and check all ancestors (not just parent) of a tip
  for (ancestor in Ancestors(tree, tip, type = "all")){ 
    # if ancestor node state from ASR = tip state
    if (N501_mk[ancestor-Ntip(tree)] == N501$AA[tip]){ 
      # update ancestor if the state of the ancestor node is the same as the tip
      find = ancestor 
    } else{break}
  }
  # if no ancestor matches, use the tip itself
  find <- ifelse(is.na(find), tip, find)
  # match the ancestor and the corresponding tip
  clade_N501$ancestor_node[which(clade_N501$tip_node == tip)] <- find 
  # fill in the ASR state of the ancestor
  clade_N501$ancestor_state[which(clade_N501$tip_node == tip)] <- ifelse(find == tip,
                                                                         # if tip itself
                                                               N501$AA[find], # tip state
                                                               N501_mk[find-Ntip(tree)])
                                                               # ancestor state
}

# check: should be the same
identical(clade_N501$tip_state, clade_N501$ancestor_state) # TRUE
```

### Characterize E484 ASR clades

#### All

```{r clade characteristics}
# size of each clade approximated by number of descending tips
clade <- clade %>% 
         group_by(ancestor_node) %>%
         mutate(size = n()) %>% 
         ungroup()

# number of emergence of each state and related clade information
emerge <- clade %>% 
          # filter(ancestor_node > Ntip(tree)) %>% # exclude tips, keep only internal nodes
          select(ancestor_state, ancestor_node, size) %>%
          unique() %>%
          group_by(ancestor_state) %>%
          mutate(times = n()) %>% # number of emergence for each state
          ungroup() %>%
          arrange(ancestor_state) %>% 
          mutate(tips = NaN) %>%
          select(ancestor_state, times, ancestor_node, size, tips) # reorder the columns

# store and join the descending tips information
for (anc in emerge$ancestor_node) {
  emerge$tips[which(emerge$ancestor_node == anc)] <- clade %>% 
                                                     filter(ancestor_node == anc) %>%
                                                     select(tip_node) %>% unique() %>%
                                                     .$tip_node %>% toString()
}

# reorder: most frequently emerging substitution -> largest clade size
emerge <- emerge %>% arrange(desc(times), desc(size))
clade <- clade %>% 
         select(ancestor_state, ancestor_node, size, tip_node, tip_label) %>%
         arrange(ancestor_state, desc(size))

# merge clade with sequence via tip_label=seqName, keep Accession_ID and mutation
clade <- clade %>% left_join(sequence, by = c("tip_label" = "seqName"))

# check
# apply(clade, 2, function(column){sum(is.na(column))})

# find the earliest and latest sample collection date of each clade
clade <- clade %>%
         group_by(ancestor_node) %>% 
         mutate(earliest = min(`Collection date`, na.rm = TRUE)) %>%
         mutate(latest = max(`Collection date`, na.rm = TRUE)) %>%
         mutate(duration = as.numeric(latest - earliest)) %>%
         # how long a clade lasted in day
         ungroup() %>% 
         mutate(tip_date_day = `Collection date` - ymd("2019-12-26")) %>%
         # day since earliest
         mutate(tip_date_week = time_length(tip_date_day, "weeks")) %>%
         # week since earliest
         mutate(tip_date_month = time_length(tip_date_day, "months")) %>%
         # month since earliest
         mutate(tip_date_day = as.numeric(tip_date_day)) 

# add time information to emerge
temp <- clade %>%
        group_by(ancestor_node) %>%
        select(ancestor_node, earliest, latest, duration) %>%
        unique() %>%
        ungroup()
emerge <- emerge %>%
          full_join(temp, by = "ancestor_node")
rm(temp)

# size summary of all clades
summary(emerge$size)
#    Min.   1st Qu.  Median  Mean   3rd Qu.  Max. 
#    1.00    1.00    1.00   59.34    1.00   2916.00

# duration summary of all clades
summary(emerge$duration)
#    Min.   1st Qu. Median   Mean  3rd Qu.  Max.
#    0.0     0.0     0.0    38.5     0.0   617.0
```

#### E484 Reference Clades

```{r}
# clades with no E484 mutation
E_clade <- clade %>% filter(ancestor_state == "E")
E_emerge <- emerge %>% filter(ancestor_state == "E")
```

#### E484 Mutated Clades

```{r E484-mutated clade clade characteristics}
# clades with any E484 mutation
E484_clade <- clade %>% filter(ancestor_state != "E")
E484_emerge <- emerge %>% filter(ancestor_state != "E")

# size summary of E484-mutated clades
summary(E484_emerge$size)
#    Min.   1st Qu. Median   Mean  3rd Qu.  Max.
#    1.0     1.0     1.0    18.3     9.0   209.0

# duration summary of E484-mutated clades
summary(E484_emerge$duration)
#    Min.   1st Qu. Median   Mean  3rd Qu.  Max. 
#    0.00    0.00    0.00   58.11   73.00  303.00
```

### Genetic Background of E484 Clades (Proportion of Other Mutations)

#### All E484K Sequences

```{r genetic background at the time of E484 mutation emergence}
# total number of sequences in all clades of E484K
K_total <- E484_clade %>% filter(ancestor_state == "K") %>% dim() %>% .[1] # 478
# E484_emerge %>% filter(ancestor_state == "K") %>% .$size %>% sum() # confirm 478 = K_total

# calculate the count and proportion of other mutations in all E484K sequences
other <- E484_clade %>%
         filter(ancestor_state == "K") %>%
         select(mutation) %>% mutate(single = str_split(mutation, ",")) %>% 
         unnest(single) %>% select(single) %>% 
         group_by(single) %>% mutate(count = n()) %>% unique() %>% ungroup() %>%
         arrange(desc(count)) %>% 
         mutate(proportion = count/K_total) %>%
         filter(single != "S:E484K")

# find potential epistatic mutations as: >= 10% proportion among all E484K sequences
key_mut <- other %>% filter(proportion >= 0.1)
```

#### Each E484 Clade

```{r other mutations with high proportions in E484K sequences in all E484 clades}
# define a function to calculate the proportion of specified mutations in each E484K clade
clade_prop <- function(ancestor){
                      # calculate the size of clade descending from an ancestor node
                      size <- emerge$size[which(emerge$ancestor_node == ancestor)]
                      # calculate the proportion of other mutations in this clade
                      prop <- clade %>% 
                              filter(ancestor_node == ancestor) %>%
                              select(mutation) %>% 
                              mutate(single = str_split(mutation, ",")) %>% 
                              unnest(single) %>% select(single) %>% 
                              group_by(single) %>% mutate(clade_count = n()) %>%
                              unique() %>% ungroup() %>%
                              arrange(desc(clade_count)) %>% 
                              mutate(clade_proportion = clade_count/size)
                      # find the proportion of potential_mutation in the clade
                      prop <- prop %>% 
                              full_join(key_mut[, "single"], by = "single") %>%
                              mutate_all(~replace(., is.na(.), 0)) %>%
                              # 0 if no such mutation 
                              filter(single %in% key_mut$single)
                      prop <- key_mut[, "single"] %>% 
                              full_join(prop, by = "single") %>% # reorder
                              select(single, clade_proportion) # remove clade_count
                      # ensure different names for the proportion column of different clades
                      names(prop) <- c("single", paste0("clade_", ancestor))
                      return(prop)
}

# find all ancestor nodes of E484K clade, excluding clades with only 1 tip (size==1)
ancestor_K <- E484_emerge %>% filter(ancestor_state == "K" & size > 1) %>% .$ancestor_node
# find all ancestor nodes of E484Q clade, excluding clades with only 1 tip (size==1)
ancestor_other <- E484_emerge %>% filter(ancestor_state != "K" & size > 1) %>% .$ancestor_node
# find all ancestor nodes of E484E ref clade, excluding clades with only 1 tip (size==1)
ancestor_E <- E_emerge %>% filter(size > 1) %>% .$ancestor_node

# calculate proportion of key_mut in all E484K clades (size > 1)
key_mut_K <- key_mut
for (anc in ancestor_K){
  key_mut_K <- key_mut_K %>% full_join(clade_prop(anc), by = "single")
}
# calculate proportion of key_mut in all E484Q/R clades (size > 1)
key_mut_other <- key_mut
for (anc in ancestor_other){
  key_mut_other <- key_mut_other %>% full_join(clade_prop(anc), by = "single")
}
key_mut_other <- key_mut_other %>% .[ , c(1, 4)] # keep necessary info to merge to key_mut_K
# E484_emerge %>% filter(ancestor_node == 5280) # E484Q-mutated clade
names(key_mut_other) <- c("single", "clade_5280_Q")

# calculate proportion of key_mut in all E484E clades (size > 1)
key_mut_E <- key_mut
for (anc in ancestor_E){
  key_mut_E <- key_mut_E %>% full_join(clade_prop(anc), by = "single")
}
key_mut_E <- key_mut_E %>% .[ , c(1, 4, 5)] # keep necessary info to merge to key_mut_K
names(key_mut_E) <- c("single", "clade_3443_E", "clade_3691_E")

# plot heat map to identify potentially interesting mutations
key_mut_K %>%
  full_join(key_mut_other, by = "single") %>%
  full_join(key_mut_E, by = "single") %>%
  pivot_longer(cols = starts_with("clade_"), 
               names_to = "clade", 
               values_to = "clade_proportion") %>%
  mutate(percent = clade_proportion * 100) %>%
  ggplot(aes(fct_inorder(as.factor(clade)), fct_rev(fct_inorder(as.factor(single))))) +
  geom_tile(aes(fill = clade_proportion), color = "grey") +
  scale_fill_gradientn(name = "Percent", colors = brewer.pal(9, "Reds"), na.value = "grey") +
  scale_x_discrete(position = "top") +
  labs(x = NULL, y = NULL, title = "Proportion of Mutations in E484K Clade")
```

### E484K vs. time

#### Raw

```{r Plot E484 Clades Characteristics, warning = FALSE}
# plot time distribution of E484-mutated clades by all samples
E484_clade %>% 
  ggplot(aes(x = `Collection date`, y = as.factor(ancestor_node))) +
  geom_point(aes(color = as.factor(ancestor_state))) +
  scale_colour_discrete(name = "Substitution") +
  labs(title = "Time Distribution of E484-mutated Clades", y = "Ancestor")

# plot time distribution of emergence by earliest sample (count)
E484_emerge %>% 
  ggplot(aes(x = earliest)) +
  geom_histogram(aes(fill = as.factor(ancestor_state)), position = "dodge") +
  scale_fill_discrete(name = "Substitution") +
  labs(title = "Time Distribution of Earliest Sample from an E484-mutated Clade", 
       x = "Time of Earliest Sample", y = "Count")

# plot time distribution of clades by earliest sample (ancestor)
E484_emerge %>% 
  ggplot(aes(x = earliest, y = as.factor(ancestor_node))) +
  geom_point(aes(color = as.factor(ancestor_state))) +
  scale_colour_discrete(name = "Substitution") +
  labs(title = "Time Distribution of Earliest Sample from an E484-mutated Clade", 
       x = "Time of Earliest Sample", y = "Ancestor")

# plot duration of clade vs. time of earliest sample
E484_emerge %>% 
  ggplot(aes(x = earliest, y = duration)) +
  geom_point(aes(size = size, color = as.factor(ancestor_state))) +
  scale_color_discrete(name = "Substitution") +
  labs(title = "E484-mutated Clade Duration vs. Time of Earliest Sample", 
       x = "Time of Earliest Sample" , y = "Duration of Clade")

# plot size of clade vs. time of earliest sample
E484_emerge %>% 
  ggplot(aes(x = earliest, y = size)) +
  geom_point(aes(color = as.factor(ancestor_state))) +
  scale_color_discrete(name = "Substitution") +
  labs(title = "E484-mutated Clade Size vs. Time of Earliest Sample", 
       x = "Time of Earliest Sample" , y = "Size of Clade")
```

#### Normalized

```{r normalized distribution of emergence over time}
# find tips that are not the first sample of a E484K clade
later_K <- E484_clade %>% 
           filter(ancestor_state == "K") %>%
           group_by(ancestor_node) %>%
           filter(`Collection date` != earliest) %>%
           ungroup() %>%
           .$tip_node

# find the first sample of a E484K clade (for logistic regression)
clade_first_K <- clade %>% 
                 filter(!(tip_node %in% later_K)) %>%
                 filter(!is.na(`Collection date`)) %>%
                 mutate(ind_K = relevel(as.factor(ifelse(ancestor_state == "K", 1, 0)),
                                        ref = "0")) # indicator for E484K mutation (0)

# check
# intersect(clade_first_K$tip_node, later_K) # 0
# sum(emerge$ancestor_state == "K")
      # 21 emergence: expect 21 first-K samples
# sum(clade_first_K$ind_K == 1, na.rm = TRUE)
      # 21 frist-K samples observed: more than 1 sample at the earliest emergence time

# categorical time bi-week
# summary(clade_first_K$tip_date_week) # range = (0, 88.14)
clade_first_K$tip_date_biweek <- cut(clade_first_K$tip_date_week,
                                     breaks=c(seq(0, 90, 2)),
                                     labels=c(seq(1, 45)))
clade_first_K$tip_date_biweek[which(clade_first_K$tip_date_day == 0)] <- 1

# plot standardized emergence by time (fornights since first sample)
clade_first_K %>% 
  group_by(as.factor(tip_date_biweek)) %>%
  mutate(biweek_size = n()) %>%
  mutate(biweek_emerge = sum(ind_K == 1)) %>%
  mutate(biweek_prop = biweek_emerge / biweek_size) %>%
  ungroup() %>%
  ggplot(aes(as.numeric(tip_date_biweek), biweek_prop)) +
  geom_point()+
  scale_x_continuous(limits = c(0, 50)) +
  scale_y_continuous(limits = c(0, 1)) +
  labs(x = "Fornights since first sample (2019/12/26)",
       y = "Standardized Emergence",
       title = "Standardized Emergence by Time")

# approximate time ranges of the 
summary(clade_first_K$`Collection date`[which(clade_first_K$tip_date_biweek == 20)])
summary(clade_first_K$`Collection date`[which(clade_first_K$tip_date_biweek == 25)])
summary(clade_first_K$`Collection date`[which(clade_first_K$tip_date_biweek == 30)])
summary(clade_first_K$`Collection date`[which(clade_first_K$tip_date_biweek == 35)])
```

#### Logistic Regression

```{r Logistic regression of emergence vs time}
# logistic regression with time = day since first sequence in sample as x
logreg_day <- glm(ind_K ~ tip_date_day, data = clade_first_K, family = "binomial")
summary(logreg_day)
clade_first_K$p_day <- predict(logreg_day, type="response", newdata=clade_first_K)
# logistic regression with time = week since first sequence in sample as x
logreg_week <- glm(ind_K ~ tip_date_week, data = clade_first_K, family = "binomial")
summary(logreg_week)
clade_first_K$p_week <- predict(logreg_week, type="response", newdata=clade_first_K)
# logistic regression with time = day since first sequence in sample as x
logreg_month <- glm(ind_K ~ tip_date_month, data = clade_first_K, family = "binomial")
summary(logreg_month)
clade_first_K$p_month <- predict(logreg_month, type="response", newdata=clade_first_K)
# check
# sum(clade_first_K$p_day == clade_first_K$p_week, na.rm = TRUE) # 0
# sum(clade_first_K$p_day == clade_first_K$p_month, na.rm = TRUE) # 0
# sum(clade_first_K$p_week == clade_first_K$p_month, na.rm = TRUE) # 0

# plot predicted value by day
clade_first_K %>%
  ggplot(aes(tip_date_day, p_day)) +
  geom_point() +
  scale_x_continuous(limits = c(0, 650)) +
  scale_y_continuous(limits = c(0, 0.01)) +
  labs(x = "Day since first sample (2019/12/26)",
       y = "Predicted Probability of K Emergence",
       title = "Predicted Probability by Day")
# plot predicted value by week
clade_first_K %>%
  ggplot(aes(tip_date_week, p_week)) +
  geom_point() +
  scale_x_continuous(limits = c(0, 92)) +
  scale_y_continuous(limits = c(0, 0.01)) +
  labs(x = "Week since first sample (2019/12/26)",
       y = "Predicted Probability of K Emergence",
       title = "Predicted Probability by Week")
# plot predicted value by month
clade_first_K %>%
  ggplot(aes(tip_date_month, p_month)) +
  geom_point() +
  scale_x_continuous(limits = c(0, 22)) +
  scale_y_continuous(limits = c(0, 0.01)) +
  labs(x = "Month since first sample (2019/12/26)",
       y = "Predicted Probability of K Emergence",
       title = "Predicted Probability by Month")
```

### E484K vs. N501Y

#### At ancestral node

##### proportion

```{r N501Y proportion at E484K clade ancestral nodes}
# vector of E484 state on all tips and internal nodes (tips followed by nodes)
E484_tip_and_node <- c(E484$AA, E484_mk)
# length(E484_tip_and_node) == (tree$Nnode + length(tree$tip.label))
      # TRUE: 6243
# vector of N501 state on all tips and internal nodes (tips followed by nodes)
N501_tip_and_node <- c(N501$AA, N501_mk)
# length(N501_tip_and_node) == (tree$Nnode + length(tree$tip.label))
      # TRUE: 6243

# find the N501 state of E484 clade ancestral nodes 
emerge <- emerge %>% 
          mutate(ancestor_N501_state = N501_tip_and_node[ancestor_node]) %>%
          select(ancestor_state, ancestor_N501_state, times, ancestor_node, size, 
                 earliest, latest, duration, tips)

# proportion of N501 states at E484 ancestral node
cbind(table(emerge$ancestor_state, emerge$ancestor_N501_state), 
      prop.table(table(emerge$ancestor_state, emerge$ancestor_N501_state), margin = 1))
```

##### logistic regression

```{r logistic regression of E484K emergence vs. N501 state at ancestral nodes}

```

#### Before ancestral node

##### proportion

```{r N501Y proportion at parent of E484K clade ancestral nodes}
# data set of all edges: time (edge length, unit = year), E484 & N501 states
edge_all <- data.frame(tree$edge)
colnames(edge_all) <- c("start", "end")
edge_all$time <- tree$edge.length * 365 # time: change unit to days?
edge_all <- edge_all %>% # E484 & N501 states
            mutate(E484_start = E484_tip_and_node[start]) %>% 
            mutate(E484_end = E484_tip_and_node[end]) %>%
            mutate(E484K_success = ifelse(E484_end == "K", 1, 0)) %>% # success = 1, censor = 0
            mutate(N501_start = N501_tip_and_node[start]) %>%
            mutate(N501_end = N501_tip_and_node[end]) %>%
            mutate(N501Y_success = ifelse(N501_end == "Y", 1, 0)) # success = 1, censor = 0

# set the reference state (E484E and N501N) as the reference levels for survival analysis
edge_all$N501_start <- relevel(factor(edge_all$N501_start), ref = "N")
edge_all$E484_start <- relevel(factor(edge_all$E484_start), ref = "E")
# levels(edge_all$N501_start) # "N" "T" "Y"
# levels(edge_all$E484_start) # "E" "K" "Q"

# edges for E484K emergence under N501 background
edge_N501_bg <- edge_all %>% 
                filter(E484_start != "K") # exclude if E484K mutation had occurred
# edges for N501Y emergence under N501 background
edge_E484_bg <- edge_all %>% 
                filter(N501_start != "Y") # exclude if N501Y mutation had occurred
```

##### logistic regression

```{r}

```

##### Survival Analysis - (vice versa = after ancestral node?)

```{r find edges that starts with N501Y internal nodes}
# summary of time to E484K emergence by N501 status of parent node (ends with any N501 states)
edge_N501_bg %>% filter(N501_start == "N") %>% filter(E484K_success == 1) %>% .$time %>% summary()
edge_N501_bg %>% filter(N501_start == "T") %>% filter(E484K_success == 1) %>% .$time %>% summary()
edge_N501_bg %>% filter(N501_start == "Y") %>% filter(E484K_success == 1) %>% .$time %>% summary()

# summary of time to N501Y emergence by E484 status of parent node (ends with any E484 states)
edge_E484_bg %>% filter(E484_start == "E") %>% filter(N501Y_success == 1) %>% .$time %>% summary()
edge_E484_bg %>% filter(E484_start == "K") %>% filter(N501Y_success == 1) %>% .$time %>% summary()
edge_E484_bg %>% filter(E484_start == "Q") %>% filter(N501Y_success == 1) %>% .$time %>% summary()

# ?????
# fix negative times for survival analysis
# ?????
edge_N501_bg$time[which(edge_N501_bg$time <= 0) ] <- 0.0000000001
edge_E484_bg$time[which(edge_E484_bg$time <= 0) ] <- 0.0000000001

# function to produce a table of (possibly exponentiated) betas, and 95% CI of survival result
get_AFT_CI <- function(fit, exponentiate = FALSE, digits = 3){
  if(exponentiate){
    round(cbind("exp(beta)" = exp(fit$coef),
                exp(confint(fit))),digits)
  } else{
    round(cbind("beta" = fit$coef,
                confint(fit)),digits)
  }
}

# Exponential Accelerated Failure Time model of E484K in N501 background
surv_exp_E484K <- survreg(Surv(time, E484K_success == 1) ~ N501_start, 
                          dist = "exponential", 
                          data = edge_N501_bg)
summary(surv_exp_E484K)
get_AFT_CI(surv_exp_E484K, exponentiate = TRUE)

# Exponential Accelerated Failure Time model of N501Y in E484 background
surv_exp_N501Y <- survreg(Surv(time, N501Y_success == 1) ~ E484_start, 
                          dist = "exponential", 
                          data = edge_E484_bg)
summary(surv_exp_N501Y)
get_AFT_CI(surv_exp_N501Y, exponentiate = TRUE)
```

#### After ancestral node???